# unhexl.ts.xl

# Copyright (C) 2010, 2011 Richard Smith <richard@ex-parrot.com>
# All rights reserved.

# ########################################################################
# Mnemonic tables

# Fixed sized entries of form
#   struct mnemonic {
#     char name[12];  # Null terminated
#     char type;      # Types 00 to 05, or FF for directives; documented below
#     char params[3]; # Meaning dependent on type; documented below
#   };
#
# List of mnemonics is terminated by an entirely null marker.

mnemonics:

# Type 00 instructions.   Void instructions (i.e. with no arguments), e.g.
#
#   NOP                     90
#
# The three parameters are: 
#   1) the number of bytes in the op-code (01 here),
#   2) the first op-code byte (90), and 
#   3) the second op-code byte (n/a here).

4E 4F 50 00  00 00 00 00  00 00 00 00    00 01 90 00    # NOP
50 55 53 48  46 00 00 00  00 00 00 00    00 01 9C 00    # PUSHF
50 4F 50 46  00 00 00 00  00 00 00 00    00 01 9D 00    # POPF
52 45 50 00  00 00 00 00  00 00 00 00    00 01 F3 00    # REP
52 45 50 45  00 00 00 00  00 00 00 00    00 01 F3 00    # REPE
52 45 50 4E  45 00 00 00  00 00 00 00    00 01 F4 00    # REPNE
4D 4F 56 53  42 00 00 00  00 00 00 00    00 01 A4 00    # MOVSB
43 4D 50 53  42 00 00 00  00 00 00 00    00 01 A6 00    # CMPSB
53 43 41 53  42 00 00 00  00 00 00 00    00 01 AE 00    # SCASB
43 42 57 00  00 00 00 00  00 00 00 00    00 02 66 98    # CBW    [aka CBTW]
43 57 44 45  00 00 00 00  00 00 00 00    00 01 98 00    # CWDE   [aka CWTL]
52 45 54 00  00 00 00 00  00 00 00 00    00 01 C3 00	# RET


# Type 01 instructions.   A single immediate 8-bit argument, e.g.
#
#   INT     imm8            CD
#
# The three parameters are: 
#   1) the number of bytes in the op-code (01 here),
#   2) the first op-code byte (CD), and 
#   3) the second op-code byte (n/a here).

49 4E 54 00  00 00 00 00  00 00 00 00    01 01 CD 00    # INT


# Type 02 instructions.   A single immediate 32-bit argument, e.g.
#
#   CALL    rel32           E8
#
# The three parameters are: 
#   1) the number of bytes in the op-code (01 here),
#   2) the first op-code byte (E8), and 
#   3) the second op-code byte (n/a here).

43 41 4C 4C  00 00 00 00  00 00 00 00    02 01 E8 00    # CALL
4A 4D 50 00  00 00 00 00  00 00 00 00    02 01 E9 00    # JMP
4A 45 00 00  00 00 00 00  00 00 00 00    02 02 0F 84    # JE
4A 47 00 00  00 00 00 00  00 00 00 00    02 02 0F 8F    # JG
4A 47 45 00  00 00 00 00  00 00 00 00    02 02 0F 8D    # JGE
4A 41 00 00  00 00 00 00  00 00 00 00    02 02 0F 87    # JA
4A 41 45 00  00 00 00 00  00 00 00 00    02 02 0F 83    # JAE
4A 4C 00 00  00 00 00 00  00 00 00 00    02 02 0F 8C    # JL
4A 4C 45 00  00 00 00 00  00 00 00 00    02 02 0F 8E    # JLE
4A 42 00 00  00 00 00 00  00 00 00 00    02 02 0F 82    # JB
4A 42 45 00  00 00 00 00  00 00 00 00    02 02 0F 86    # JBE
4A 4E 45 00  00 00 00 00  00 00 00 00    02 02 0F 85    # JNE
4A 43 00 00  00 00 00 00  00 00 00 00    02 02 0F 82    # JC == JB
4A 4F 00 00  00 00 00 00  00 00 00 00    02 02 0F 80    # JO


# Type 03 instructions.   A single r/m8 operand, e.g.
#
#   INCB    r/m8            FE /0
#
# The three parameters are:
#   1) the number 1 (to allow it to be treated as the opcode length)
#   2) the op-code byte (FE), and 
#   3) the three-bit reg field for the ModR/M byte (0 here).

49 4E 43 42  00 00 00 00  00 00 00 00    03 01 FE 00    # INCB
44 45 43 42  00 00 00 00  00 00 00 00    03 01 FE 01    # DECB
4E 45 47 42  00 00 00 00  00 00 00 00    03 01 F6 03	# NEGB
53 41 4C 42  00 00 00 00  00 00 00 00    03 01 D2 04    # SALB  [%cl]
53 48 4C 42  00 00 00 00  00 00 00 00    03 01 D2 04    # SHLB  [%cl]
53 41 52 42  00 00 00 00  00 00 00 00    03 01 D2 07    # SARB  [%cl]
53 48 52 42  00 00 00 00  00 00 00 00    03 01 D2 05    # SHRB  [%cl]
4D 55 4C 42  00 00 00 00  00 00 00 00    03 01 F6 04	# MULB  [%eax]
49 4D 55 4C  42 00 00 00  00 00 00 00    03 01 F6 05	# IMULB [%eax]
44 49 56 42  00 00 00 00  00 00 00 00    03 01 F6 06	# DIVB  [%eax]
49 44 49 56  42 00 00 00  00 00 00 00    03 01 F6 07	# IDIVB [%eax]


# Type 04 instructions.   A single r/m32 operand, e.g.
#
#   INCL    r/m32           FF /0
#
# The three parameters are:
#   1) the number 1 (to allow it to be treated as the opcode length)
#   2) the op-code byte (FF), and 
#   3) the three-bit reg field for the ModR/M byte (0 here).

49 4E 43 4C  00 00 00 00  00 00 00 00    04 01 FF 00    # INCL
44 45 43 4C  00 00 00 00  00 00 00 00    04 01 FF 01    # DECL
4E 45 47 4C  00 00 00 00  00 00 00 00    04 01 F7 03	# NEGL
50 55 53 48  00 00 00 00  00 00 00 00    04 01 FF 06    # PUSH
50 4F 50 00  00 00 00 00  00 00 00 00    04 01 8F 00    # POP
53 41 4C 4C  00 00 00 00  00 00 00 00    04 01 D3 04    # SALL  [%cl]
53 48 4C 4C  00 00 00 00  00 00 00 00    04 01 D3 04    # SHLL  [%cl]
53 41 52 4C  00 00 00 00  00 00 00 00    04 01 D3 07    # SARL  [%cl]
53 48 52 4C  00 00 00 00  00 00 00 00    04 01 D3 05    # SHRL  [%cl]
4D 55 4C 4C  00 00 00 00  00 00 00 00    04 01 F7 04	# MULL  [%eax]
49 4D 55 4C  4C 00 00 00  00 00 00 00    04 01 F7 05	# IMULL [%eax]
44 49 56 4C  00 00 00 00  00 00 00 00    04 01 F7 06	# DIVL  [%eax]
49 44 49 56  4C 00 00 00  00 00 00 00    04 01 F7 07	# IDIVL [%eax]


# Type 05 instructions.   An r/m32 operand followed by a r32 operand:
#
#   LEA     r/m32, r32      8D
#
# The three parameters are: 
#   1) the number of bytes in the op-code (01 here),
#   2) the first op-code byte (8D), and 
#   3) the second op-code byte (n/a here).

4C 45 41 00  00 00 00 00  00 00 00 00    05 01 8D 00	# LEA


# Type 06 instructions.   These represent a large family of op-codes, e.g.
#
#   MOVB    r8, r/m8        88         } These two opcodes are constrained
#   MOVB    r/m8, r8        8A         } to $N and $N+2.
#   MOVB    imm8, r/m8      C6 /0
#
# The three parameters are:
#   1) the r8, r/m8 op code (88 here), the 
# immediate op code (C6 here), and the three op-code extension bits
# that are in the reg part of the mod-r/m byte (0 here).

4D 4F 56 42  00 00 00 00  00 00 00 00    06 88 C6 00    # MOVB
41 44 44 42  00 00 00 00  00 00 00 00    06 00 80 00    # ADDB
53 55 42 42  00 00 00 00  00 00 00 00    06 28 80 05    # SUBB
43 4D 50 42  00 00 00 00  00 00 00 00    06 38 80 07    # CMPB
41 4E 44 42  00 00 00 00  00 00 00 00    06 20 80 04    # ANDB
4F 52 42 00  00 00 00 00  00 00 00 00    06 08 80 01    # ORB
58 4F 52 42  00 00 00 00  00 00 00 00    06 30 80 06    # XORB


# Type 07 instructions.   These represent a large family of op-codes, e.g.
#
#   MOVL    r32,r/m32       89         } These two opcodes are constrained
#   MOVL    r/m32,r32       8B         } to $N and $N+2.
#   MOVL    imm32,r/m32     C7 /0
#
# The three parameters are the register op code (88 here), the 
# immediate op code (C6 here), and the three op-code extension bits
# that are in the reg part of the mod-r/m byte (0 here).

4D 4F 56 4C  00 00 00 00  00 00 00 00    07 89 C7 00    # MOVL
41 44 44 4C  00 00 00 00  00 00 00 00    07 01 81 00    # ADDL
53 55 42 4C  00 00 00 00  00 00 00 00    07 29 81 05    # SUBL
43 4D 50 4C  00 00 00 00  00 00 00 00    07 39 81 07    # CMPL
41 4E 44 4C  00 00 00 00  00 00 00 00    07 21 81 04    # ANDL
4F 52 4C 00  00 00 00 00  00 00 00 00    07 09 81 01    # ORL
58 4F 52 4C  00 00 00 00  00 00 00 00    07 31 81 06    # XORL


# Type FF 'instructions'.  These are actually directives.    
#
#   .hex_bytes
#
# The sole parameter is an unique code used internally to represent the 
# directive.  Each directive is special-cased in the code.

2E 68 65 78  5F 62 79 74  65 73 00 00    FF 00 00 00    # .hex_bytes



# End of table marker -- first byte of name is NULL.
00 00 00 00  00 00 00 00  00 00 00 00    00 00 00 00 
# ########################################################################


####	#  Function: void* getip(void)
	#  A function to load %eip for the calling frame (specifically
	#  the return address) into %eax.  The usual trick of
	#    CALL next_line; next_line: POP $eax
	#  relies on a forward jump, so we need a separate function.
getip:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 04		#	MOVL	4(%ebp), %eax
	5D      		#	POP	%ebp
	C3   			#	RET

####    #  Function: bool ishws(char)
	#  Tests whether its argument is in [ \t]

	#  As with many of the functions here, it is turned upside down
	#  so the entry point is in the middle.  This is because unhexl
	#  is limited to jumps up the file.
.L1:
	5D			#	POP	%ebp
	C3			#	RET
ishws:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
.L1a:
	3C 20			#	CMPB	$0x20, %al	# ' '
	0F 84 .L1		#	JE	.L1
	3C 09			#	CMPB	$0x09, %al	# '\t'
	0F 84 .L1		#	JE	.L1
	31 C0			#	XORL	%eax, %eax
	E9 .L1			#	JMP	.L1

####    #  Function: bool isws(char)
	#  Tests whether its argument is in [ \t\r\n]
isws:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
	3C 09			#	CMPB	$0x0D, %al	# '\r'
	0F 84 .L1		#	JE	.L1
	3C 0A			#	CMPB	$0x0A, %al	# '\n'
	0F 84 .L1		#	JE	.L1
	E9 .L1a			#	JMP	.L1a


####	#  Function: bool isidchr(char)
	#  Tests whether its argument is in [0-9A-Za-z_]
.L2:
	31 C0			#	XORL	%eax, %eax
.L3:
	5D			#	POP	%ebp
	C3			#	RET
isidchr:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
	3C 30			#	CMPB	$0x30, %al	# '0'
	0F 8C .L2		#	JL	.L2
	3C 39			#	CMPB	$0x39, %al	# '9'
	0F 8E .L3		#	JLE	.L3
.L3a:
	3C 41			#	CMPB	$0x41, %al	# 'A'
	0F 8C .L2		#	JL	.L2
	3C 5A			#	CMPB	$0x5A, %al	# 'Z'
	0F 8E .L3		#	JLE	.L3
	3C 5F			#	CMPB	$0x5F, %al	# '_'
	0F 84 .L3		#	JE	.L3
	3C 61			#	CMPB	$0x61, %al	# 'a'
	0F 8C .L2		#	JL	.L2
	3C 7A			#	CMPB	$0x7A, %al	# 'z'
	0F 8E .L3		#	JLE	.L3
	E9 .L2			#	JMP	.L2


####	#  Function: bool isid1chr(char)
	#  Tests whether its argument is in [.A-Za-z_]
isid1chr:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
	3C 2E			#	CMPB	$0x2E, %al	# '.'
	0F 84 .L3		#	JE	.L3
	E9 .L3a			#	JMP	.L3a


####	#  Function: int xchr(int c)
	#  Tests whether its argument, c, is a character in [0-9A-F], and if 
	#  so, coverts it to an integer; otherwise returns -1.
.L6:
	2C 37			#	SUBB	$0x37, %al	# 'A'-10
.L7:
	5D			#	POP	%ebp
	C3			#	RET
.L4:
	C6 C0 FF		#	MOVB	$-1, %al
	E9 .L7			#	JMP	.L7
.L5:
	2C 30			#	SUBB	$0x30, %al	# '0'
	E9 .L7			#	JMP	.L7
xchr:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
	3C 30			#	CMPB	$0x30, %al	# '0'
	0F 8C .L4		#	JL	.L4
	3C 39			#	CMPB	$0x39, %al	# '9'
	0F 8E .L5		#	JLE	.L5
	3C 41			#	CMPB	$0x41, %al	# 'A'
	0F 8C .L4		#	JL	.L4
	3C 46			#	CMPB	$0x46, %al	# 'F'
	0F 8E .L6		#	JLE	.L6
	E9 .L4			#	JMP	.L4


####	#  Function: int dchr(int c)
	#  Tests whether its argument, c, is a character in [0-9], and if 
	#  so, coverts it to an integer; otherwise returns -1.
dchr:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	8B 45 08		#	MOVL	8(%ebp), %eax
	3C 30			#	CMPB	$0x30, %al	# '0'
	0F 8C .L4		#	JL	.L4
	3C 39			#	CMPB	$0x39, %al	# '9'
	0F 8E .L5		#	JLE	.L5
	E9 .L4			#	JMP	.L4


####    #  Not a proper function.
	#  Exits program
error:
	BB 01 00 00 00          #       MOVL    $1, %ebx
success:
	B8 01 00 00 00          #       MOVL    $1, %eax   # 1 == __NR_exit
	CD 80                   #       INT     $0x80


####	#  Function:	void writebyte( int c, ofile* of )
	#  Write out character c
.L5d:
	5B			#	POP	%ebx
	5D			#	POP	%ebp
	C3			#	RET

writebyte:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	BA 01 00 00 00		#	MOVL	$1, %edx
	
.L5a:
	53			#	PUSH	%ebx

	#  Increment counter
	8B 5D 0C		#	MOVL	12(%ebp), $ebx
	01 53 04		#	ADDL	%edx, 4(%ebx)	# inc counter

	#  If the fd is -ve, we're not actually writing
	8B 1B 			#	MOVL	(%ebx), %ebx	# fd from ofile
	83 FB 00		#	CMPL	$0, %ebx
	0F 8C .L5d		#	JL	.L5d

	8D 4D 08		#	LEA	8(%ebp), %ecx	# ofile*
	B8 04 00 00 00		#	MOVL	$4, %eax   # 4 == __NR_write
	CD 80			#	INT	$0x80
	E9 .L5d			#	JMP	.L5d


####	#  Function:	void writedword( int dw, ofile* of )
	#  Write out dword dw
writedword:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	BA 04 00 00 00		#	MOVL	$4, %edx
	E9 .L5a			#	JMP	.L5a


####	#  Function:	void writedata( int bits, int data, ofile* of )
.L5b:
	E8 writebyte		#	CALL	writebyte
.L5c:
	5A			#	POP	%edx
	5A			#	POP	%edx
	5D			#	POP	%ebp
	C3			#	RET

writedata:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	FF 75 10		#	PUSH	16(%ebp)	# ofile
	FF 75 0C		#	PUSH	12(%ebp)	# data
	
	83 7D 08 08		#	CMPL	$8, 8(%ebp)
	0F 84 .L5b		#	JE	.L5b
	E8 writedword		#	CALL	writedword
	E9 .L5c			#	JMP	.L5c
	

####	#  Function:	void unread( char c, ifile* f )
	#  Puts c onto the pushback slot
unread:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp

	#  Locate the pback_slot.
	8B 45 0C		#	MOVL	12(%ebp), $eax
	80 78 04 00		#	CMPB	$0, 4(%eax)  # Test has_pback?
	0F 85 error		#	JNE	error

	#  Write to the pback_slot
	C6 40 04 01		#	MOVB	$1, 4(%eax)
	8A 4D 08		#	MOVB	8(%ebp), $cl
	88 48 05		#	MOVB	%cl, 5(%eax)
	5D			#	POP	%ebp
	C3			#	RET
	

####	#  Function:	void readone( char* p, ifile* f ) 
	#  Reads one byte into p which should already be set.
	#  Returns the number of bytes read in %eax.
	#
	#  This function contains the sole read syscall (syscall #3) so we 
	#  can plumb in use of the pushback slot (pback_slot)
.L9:
	BA 01 00 00 00		#	MOVL	$1, %edx
	8B 1B 			#	MOVL	(%ebx), %ebx	# fd from ifile
	B8 03 00 00 00		#	MOVL	$3, %eax	# 3 = __NR_read
	CD 80			#	INT	$0x80
.L9a:
	5B			#	POP	%ebx
	5D			#	POP	%ebp
	C3			#	RET
	
readone:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	53			#	PUSH	%ebx
	8B 4D 08		#	MOVL	8(%ebp), %ecx

	#  Locate the pback_slot.
	8B 5D 0C		#	MOVL	12(%ebp), $ebx
	80 7B 04 00		#	CMPB	$0, 4(%ebx)  # Test has_pback?
	0F 84 .L9		#	JE	.L9

	#  The pback_slot has a value in it
	C6 43 04 00		#	MOVB	$0, 4(%ebx)
	8A 43 05		#	MOVB    5(%ebx), %al
	88 01			#	MOVB	%al, (%ecx)
	B8 01 00 00 00		#	MOVL	$1, %eax
	E9 .L9a			#	JMP	.L9a


####	#  Function:	void readonex( char* p, ifile* f ) 
	#  Reads one byte into p which should already be set (as above);
	#  exits unsuccessfully in case of error reading.
readonex:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp

	FF 75 0C		#	PUSH	12(%ebp)
	FF 75 08		#	PUSH	8(%ebp)
	E8 readone		#	CALL	readone
	5A			#	POP	%edx
	5A			#	POP	%edx

	83 F8 01		#	CMPL	$1, %eax
	0F 85 error		#	JNE	error

	5D			#	POP	%ebp
	C3			#	RET


####	#  Function:	int getone( ifile* in )
	#  Reads a byte into a temporary buffer (which is freed again) and 
	#  returns the byte.  Exits on error or failure to read.
getone:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# char buf[4];

	FF 75 08		#	PUSH	8(%ebp)
	8D 4D FC		#	LEA	-4(%ebp), %ecx	# char* bufp;
	51			#	PUSH	%ecx

	E8 readonex		#	CALL	readonex
	8A 45 FC		#	MOVB	-4(%ebp), %al

	83 C4 0C		#	ADDL	$12, %esp
	5D			#	POP	%ebp
	C3			#	RET


####	#  Function:	int read_r32( ifile* in )
	#  We've already read a '%'.  Now read a 32-bit register name.  Return
	#    0 => %eax, 1 => %ecx, 2 => %edx, 3 => %ebx
	#    4 => %esp, 5 => %ebp, 6 => %esi, 7 => %edi
.L9h:
	89 C8			#	MOVL	%ecx, %eax
	5A			#	POP	%edx		# value
	5A			#	POP	%edx		# ifile
	5D			#	POP	%ebp
	C3			#	RET

.L9g:
	#  Is it %esp or %esi?
	89 4D FC		#	MOVL	%ecx, -4(%ebp)	# value
	E8 getone		#	CALL	getone
	8B 4D FC		#	MOVL	-4(%ebp), %ecx	# value
	3C 70			#	CMPB	$0x70, $al	# 'p'
	0F 84 .L9h		#	JE	.L9h
	3C 69			#	CMPB	$0x69, $al	# 'i'
	0F 85 error		#	JNE	error
	B9 06 00 00 00		#	MOVL	$6, %ecx	# == %esi
	E9 .L9h			#	JMP	.L9h

.L9f:
	#  Is it %edi?
	3C 69			#	CMPB	$0x69, $al	# 'i'
	0F 85 error		#	JNE	error
	B9 07 00 00 00		#	MOVL	$7, %ecx	# == %edi
	E9 .L9h			#	JMP	.L9h
	
.L9e:
	#  We've had %e[a-d][^x]
	83 F9 02		#	CMPL	$2, %ecx
	0F 8C error		#	JL	error		# %ea* / %ec*
	0F 84 .L9f		#	JE	error		# %ed*

	#  Is it %ebp?
	3C 70			#	CMPB	$0x70, $al	# 'p'
	0F 85 error		#	JNE	error
	B9 05 00 00 00		#	MOVL	$5, %ecx	# == %ebp
	E9 .L9h			#	JMP	.L9h
	
.L9d:	
	#  Have parsed two characters of %eax or %ecx, check for 'x'
	89 4D FC		#	MOVL	%ecx, -4(%ebp)	# value
	E8 getone		#	CALL	getone
	8B 4D FC		#	MOVL	-4(%ebp), %ecx	# value
	3C 78			#	CMPB	$0x78, $al	# 'x'
	0F 85 .L9e		#	JNE	.L9e
	E9 .L9h			#	JMP	.L9h

read_r32:
	55 			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# value

	#  Read the first character which must be an 'e'
	FF 75 08		#	PUSH	8(%ebp)		# ifile
	E8 getone		#	CALL	getone
	80 F8 65		#	CMPB	$0x65, %al	# 'e'
	0F 85 error		#	JNE	error

	#  Read the second character
	E8 getone		#	CALL	getone
	8B 4D FC		#	MOVL	-4(%ebp), %ecx	# value
	80 F8 61		#	CMPB	$0x61, %al	# 'a'
	0F 84 .L9d		#	JE	.L9d
	41			#	INCL	%ecx
	80 F8 63		#	CMPB	$0x63, %al	# 'c'
	0F 84 .L9d		#	JE	.L9d
	41			#	INCL	%ecx
	80 F8 64		#	CMPB	$0x64, %al	# 'd'
	0F 84 .L9d		#	JE	.L9d
	41			#	INCL	%ecx
	80 F8 62		#	CMPB	$0x62, %al	# 'b'
	0F 84 .L9d		#	JE	.L9d
	41			#	INCL	%ecx
	80 F8 73		#	CMPB	$0x73, %al	# 's'
	0F 84 .L9g		#	JE	.L9g
	E9 error		#	JMP	error


####	#  Function:	int read_r8( ifile* in )
	#  We've already read a '%'.  Now read an 8-bit register name.  Return
	#    0 => %al,  1 => %cl,  2 => %dl,  3 => %bl
	#    4 => %ah,  5 => %ch,  6 => %dh,  7 => %bh
.L9c:
	89 C8			#	MOVL	%ecx, %eax
	5A			#	POP	%edx		# value
	5A			#	POP	%edx		# ifile
	5D			#	POP	%ebp
	C3			#	RET

.L9b:
	#  Read and parse the second character
	89 4D FC		#	MOVL	%ecx, -4(%ebp)	# value
	E8 getone		#	CALL	getone
	8B 4D FC		#	MOVL	-4(%ebp), %ecx	# value
	80 F8 6C		#	CMPB	$0x6C, %al	# 'l'
	0F 84 .L9c		#	JE	.L9c
	83 C1 04		#	ADDL	$4, %ecx
	80 F8 68		#	CMPB	$0x68, %al	# 'h'
	0F 84 .L9c		#	JE	.L9c
	E9 error		#	JMP	error

read_r8:
	55 			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# value

	#  Read the first character
	FF 75 08		#	PUSH	8(%ebp)		# ifile
	E8 getone		#	CALL	getone
	8B 4D FC		#	MOVL	-4(%ebp), %ecx	# value

	#  Parse the first character
	80 F8 61		#	CMPB	$0x61, %al	# 'a'
	0F 84 .L9b		#	JE	.L9b
	41			#	INCL	%ecx
	80 F8 63		#	CMPB	$0x63, %al	# 'c'
	0F 84 .L9b		#	JE	.L9b
	41			#	INCL	%ecx
	80 F8 64		#	CMPB	$0x64, %al	# 'd'
	0F 84 .L9b		#	JE	.L9b
	41			#	INCL	%ecx
	80 F8 62		#	CMPB	$0x62, %al	# 'b'
	0F 84 .L9b		#	JE	.L9b
	E9 error		#	JMP	error


####	#  Function:	int read_reg( int bits, ifile* in )
	#  Read a 8- or 32-bit register name, depending on BITS.  The
	#  leading '%' must already be read.
.L13:
	E8 read_r8		#	CALL	read_r8
.L13a:
	59			#	POP	%ecx
	5D			#	POP	%ebp
	C3			#	RET

read_reg:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	FF 75 0C		#	PUSH	12(%ebp)	# ifile

	83 7D 08 08		#	CMPL	$8, 8(%ebp)
	0F 84 .L13		#	JE	.L13
	E8 read_r32		#	CALL	read_r32
	E9 .L13a		#	JMP	.L13a

####	#  Function:	int skiphws( ifile* );
	#  Skip horizontal whitespace until a non-whitespace character 
	#  which is unread and returned.
skiphws:
	#  The function entry point
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp

	#  Read one byte 
	FF 75 08		#	PUSH	8(%ebp)		# ifile
.L15:
	E8 getone		#	CALL	getone

	#  Is the byte horizontal white space?  If so, loop back
	50			#	PUSH	%eax
	E8 ishws		#	CALL	ishws
	83 F8 00		#	CMPL	$0, %eax
	58			#	POP	%eax
	0F 85 .L15		#	JNE	.L15

	#  Unread the last character read
	50			#	PUSH	%eax
	E8 unread		#	CALL	unread
	58			#	POP	%eax

	#  Stack cleanup and exit
	5A			#	POP	%edx
	5D			#	POP	%ebp
	C3			#	RET
	

####	#  Function:	int read_int( int bits, ifile* in );
	#  Read an integer: either decimal (which must not have a leading 0),
	#  or hex (which must have an 0x prefix).  Error on overflow.
.L17:
	#  Have we read any digits?  If not, it's an error
	83 7D F8 00		#	CMPL	$0, -8(%ebp)
	0F 84 error		#	JE	error

.L17a:
	#  Unread the last character read (now in %edx)
	52			#	PUSH	%edx
	E8 unread		#	CALL	unread
	5A			#	POP	%edx		# char

.L17b:
	#  Stack cleanup and exit
	5A			#	POP	%edx		# ifile
	5A			#	POP	%edx		# count
	58			#	POP	%eax		# ret val
	5D			#	POP	%ebp
	C3			#	RET

.L17c:
	#  Have we an overflow?  Don't care if bits == 32
	80 7D 08 20		#	CMPB	$32, 8(%ebp)
	0F 84 .L17		#	JE	.L17

	#  This branch is only used for decimals and before applying the
	#  minus sign.   We only test whether it's >= 2^bits because 
	#  we don't know whether 200 is a valid unsigned 8-bit number or
	#  an invalid signed 8-bit number.
	B8 01 00 00 00		#	MOVL	$1, %eax
	8B 4D 08		#	MOVL	8(%ebp), %ecx
	D3 E0			#	SALL	%cl, %eax
	39 45 FC		#	CMPL	$eax, -4(%ebp)
	0F 83 error		#	JAE	error

	E9 .L17			#	JMP	.L17

.L16:
	#  We're reading decimal and the first digit is already in %eax
	50			#	PUSH	%eax
	E8 dchr			#	CALL	dchr
	5A			#	POP	%edx		# char
	3C FF			#	CMPB	$-1, %al
	0F 84 .L17c		#	JE	.L17		# done
	
	#  Add the digit to the current value -- tedious as MUL only
	#  acts on the accumulator and cannot read immediates.  Test for
	#  overflow as we go along by using the fact that MUL and ADDL
	#  are both signed operations which set the OF flag on overflow.
	50			#	PUSH	%eax		# this digit
	8B 45 FC		#	MOVL	-4(%ebp), %eax	# value so far
	B9 0A 00 00 00		#	MOVL	$10, %ecx
	F7 E1 			#	MUL	%ecx, %edx:%eax	# val *= 10
	0F 80 error		#	JO	error
	5A			#	POP	%edx		# digit
	01 D0			#	ADDL	%edx, %eax	# val += digit
	0F 80 error		#	JO	error
	89 45 FC		#	MOVL	%eax, -4(%ebp)	# store val
	FF 45 F8		#	INCL	-8(%ebp)	# inc counter

	#  Read another digit
	E8 getone		#	CALL	getone
	E9 .L16			#	JMP	.L16		# loop

.L16b:
	#  This would be where we'd consider octal, if we cared about it.
	#  We don't, but we do care about the special case of zero, so we
	#  assume anything begining '0' but not continuing 'x' is a plain
	#  zero.  We'll get an error parsing the next token if we were wrong.
	E8 getone		#	CALL	getone
	3C 78			#	CMPB	$0x78, %al	# 'x'
	89 C2			#	MOVL	$eax, $edx
	0F 85 .L17a		#	JNE	.L17a

	#  Set number of hex digits (divide number of bits by 4)
	C6 C1 02		#	MOVB	$2, %cl
	D3 7D 08		#	SARL	%cl, 8(%ebp)

.L18:
	#  We know we're going to have a hex number, so start reading
	E8 getone		#	CALL	getone
	50			#	PUSH	%eax
	E8 xchr			#	CALL	xchr
	5A			#	POP	%edx		# char
	3C FF			#	CMPB	$-1, %al
	0F 84 .L17		#	JE	.L17	# done

	#  Add the digit to the current value
	C6 C1 04		#	MOVB	$4, %cl
	D3 65 FC		#	SALL	%cl, -4(%ebp)
	01 45 FC		#	ADDL	%eax, -4(%ebp)
	FF 45 F8		#	INCL	-8(%ebp)

	#  Test for overflow: 
	#  have we read more than the expected number of digits?
	8B 45 08		#	MOVL	8(%ebp), %eax
	39 45 F8		#	CMPL	%eax, -8(%ebp)
	0F 8F error		#	JG	error
	E9 .L18			#	JMP	.L18	# loop

.L18a:
	F7 D8			#	NEGL	%eax
	89 45 FC		#	MOVL	%eax, -4(%ebp)	# save
	E9 .L17b		#	JMP	.L17b

read_int:
	#  The function entry point
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# int val = 0;
	51			#	PUSH	%ecx		# int count = 0;

	#  Have as got an '0' followed by an 'x'?
	FF 75 0C		#	PUSH	12(%ebp)	# ifile
	E8 getone		#	CALL	getone
	3C 30			#	CMPB	$0x30, %al	# '0'
	0F 84 .L16b		#	JE	.L16b		# hex / zero
	3C 2D			#	CMPB	$0x2D, %al	# '-'
	0F 85 .L16		#	JNE	.L16		# deciml

	#  Recurse to read_int and negate the answer
	FF 75 0C		#	PUSH	12(%ebp)
	FF 75 08		#	PUSH	8(%ebp)
	E8 read_int		#	CALL	read_int
	5A			#	POP	%edx
	5A			#	POP	%edx

	#  Have we an overflow?  Don't care if bits == 32
	80 7D 08 20		#	CMPB	$32, 8(%ebp)
	0F 84 .L18a		#	JE	.L18a

	#  This branch is only used for decimals and before applying the
	#  minus sign.   We only test whether it's >= 2^bits because 
	#  we don't know whether 200 is a valid unsigned 8-bit number or
	#  an invalid signed 8-bit number.
	BA 01 00 00 00		#	MOVL	$1, %edx
	8B 4D 08		#	MOVL	8(%ebp), %ecx
	FF C9			#	DECL	%ecx
	D3 E2			#	SALL	%cl, %edx
	39 D0			#	CMPL	$edx, %eax
	0F 87 error		#	JA	error
	E9 .L18a		#	JMP	.L18a


####	#  Function:	int read_rm( int bits, int* disp, ifile* in )
	#  Skip whitespace then read an r/m8 or r/m32 depending on BITS.  
	#  Returns the ModR/M byte and if a displacement is present, stores 
	#  it in disp.
.L15b:
	#  It's not a '(' or '%' so it must be the start of a number
	50			# 	PUSH	%eax
	E8 unread		#	CALL	unread
	5A			#	POP	%edx
	B8 20 00 00 00		#	MOVL	$32, %eax	# bits
	50			#	PUSH	%eax
	E8 read_int		#	CALL	read_int
	5A			#	POP	%edx
	8B 4D 0C		#	MOVL	12(%ebp), %ecx	# int* disp32
	89 01			#	MOVL	%eax, (%ecx)	# store disp
	
	#  We now must have a '('
	E8 getone		#	CALL	getone
	3C 28			#	CMPB	$0x28, %al	# '('
	0F 85 error		#	JNE	error

	#  Save 0x80 for |= later
	C7 45 F8 80 00 00 00	#	MOVL	$0x80, -8(%ebp)

.L15a:
	#  If we've jumped here directly, -8(%ebp) [or val] is zero.
	#  Have read a '('; now we must read a '%'.  (ifile already on stack.)
	E8 getone		#	CALL	getone
	3C 25			#	CMPB	$0x25, %al	# '%'
	0F 85 error		#	JNE	error

	E8 read_r32		#	CALL	read_r32
	89 45 FC		#	MOVL	%eax, -4(%ebp)	# save

	#  Register code is in -4(%ebp).  Skip ')'
	E8 getone		#	CALL	getone
	3C 29			#	CMPB	$0x29, %al	# ')'
	0F 85 error		#	JNE	error

.L15c:
	#  Clean up stack and |= with or val in -8(%ebp)
	5A			#	POP	%edx		# ifile
	5A			#	POP	%edx		# or val
	58			#	POP	%eax		# ret val
	0A C2			#	ORB	%dl, %al

	#  0x04 == (%esp), 0x05 == (%ebp) and 0x84 == DISP(%esp) are invalid
	3C 04			#	CMPB	$0x04, %al
	0F 84 error		#	JE	error
	3C 05			#	CMPB	$0x05, %al
	0F 84 error		#	JE	error
	3C 84			#	CMPB	$0x84, %al
	0F 84 error		#	JE	error

	5D			#	POP	%ebp
	C3			#	RET

read_rm:
	55 			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# for ret val
	51			#	PUSH	%ecx		# for or val

	#  What sort of argument is it?  Direct memory accesses will begin '(',
	#  registers will start with an '%', and memory accesses with
	#  a displacement will start with a number?
	FF 75 10		#	PUSH	16(%ebp)	# ifile
	E8 skiphws		#	CALL	skiphws
	E8 getone		#	CALL	getone
	3C 28			#	CMPB	$0x28, %al	# '('
	0F 84 .L15a		#	JE	.L15a
	3C 25			#	CMPB	$0x25, %al	# '%'
	0F 85 .L15b		#	JNE	.L15b

	#  Save 0xC0 for |= later
	C7 45 F8 C0 00 00 00	#	MOVL	$0xC0, -8(%ebp)

	#  Read the 32-bit register name (ifile is still on stack)
	FF 75 08		#	PUSH	8(%ebp)		# bits
	E8 read_reg		#	CALL	read_reg
	59			#	POP	%ecx
	89 45 FC		#	MOVL	%eax, -4(%ebp)	# save
	E9 .L15c		#	JMP	.L15c

	
####	#  Function:	int get_label( int strlen, int bits, main_frame* p ):
	#  Lookup the text in p->buffer (which has known length strlen),
	#  Convert it to an offset relative to the current instruction
	#  (we're assumed to have written the opcode and any ModR/M bytes,
	#  so the end of instruction happens after writing the number of bits
	#  in the BITS parameter).  Check the offset can be expressed as a
	#  BITS-bit signed (2's-complement) integer.
.L11b:
	#  The label wasn't found.  Only allow this if we're not writing.
	81 BB 90 EF FF FF 00 00 00 00 #	CMPL	$0, -4208(%ebx)
	0F 8D error		#	JGE	error
	31 C0			#	XORL	%eax, %eax

.L11a:
	5F			#	POP	%edi
	5E			#	POP	%esi
	5B			#	POP	%ebx
	5D			#	POP	%ebp
	C3			#	RET

get_label:
	55 			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	53			#	PUSH	%ebx
	56			#	PUSH	%esi
	57			#	PUSH	%edi

	8B 4D 08		#	MOVL	8(%ebp), %ecx	# strlen
	8B 5D 10		#	MOVL	16(%ebp), %ebx
	8D 73 A0		#	LEA	-96(%ebx), %esi
	8D BB 90 EF FF FF	#	LEA	-4208(%ebx), %edi

	#  Null terminate
	89 F2			#	MOVL	%esi, %edx
	01 CA			#	ADDL	%ecx, %edx
	31 C0			#	XORL	%eax, %eax
	89 02			#	MOVL	%eax, (%edx)
	FF C1			#	INCL	%ecx

	51			#	PUSH	%ecx
.L11:
	59			#	POP	%ecx

	83 C7 10		#	ADDL	$16, %edi
	3B 7B F8		#	CMPL	-8(%ebx), %edi
	0F 8D .L11b		#	JGE	.L11b
	51			#	PUSH	%ecx
	56			#	PUSH	%esi
	57			#	PUSH	%edi
	F3			#	REPE
	   A6			#	  CMPSB
	5F			#	POP	%edi
	5E			#	POP	%esi
	0F 85 .L11		#	JNE	.L11
	81 F9 00 00 00 00	#	CMPL	$0, %ecx
	0F 85 .L11		#	JNE	.L11
	59			#	POP	%ecx

	#  Found it.  Compute the value.
	8B 45 0C		#	MOVL	12(%ebp), %eax
	C6 C1 03		#	MOVB	$3, %cl
	D3 F8			#	SARL	%cl, %eax
	03 83 94 EF FF FF	#	ADDL	-4204(%ebx), %eax #ofile->count
	2B 47 0C		#	SUBL	12(%edi), %eax
	F7 D8			#	NEGL	%eax

	#  %eax is the offset.  If bits == 32, don't care about overflow
	83 7D 0C 20		#	CMPL	$32, 12(%ebp)
	0F 84 .L11a		#	JE	.L11a
	
	#  Is it >= 2^(bits-1) ?
	8B 4D 0C		#	MOVL	12(%ebp), %ecx
	FF C9			#	DECL	%ecx
	BA 01 00 00 00		#	MOVL	$1, %edx
	D3 E2			#	SALL	%cl, %edx
	39 C2			#	CMPL	%eax, %edx
	0F 8E error		#	JLE	error

	#  Or < 2^(bits-1)?
	F7 DA			#	NEG	%edx
	39 C2			#	CMPL	%eax, %edx
	0F 8F error		#	JG	error
	E9 .L11a		#	JMP	.L11a


####	#  Function:	char* read_id( main_frame* p );
	#  The first byte of an identifier is already p->buf[0].  We 
	#  first confirm it isid1chr() and abort if not.  Then read 
	#  until we reach the end of the id and return a pointer to 
	#  the first non-id char.
read_id:
	55 			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp

	#  Was the first byte a valid character for an identifier?
	8B 4D 08		#	MOVL	8(%ebp), %ecx
	FF 71 A0 		#	PUSH	-96(%ecx)
	E8 isid1chr		#	CALL	isid1chr
	59			#	POP	%ecx
	83 F8 00		#	CMPL	$0, %eax
	0F 84 error		#	JE	error

	#  Continue to read an identifier
	8B 45 08		#	MOVL	8(%ebp), %eax
	8D 88 98 EF FF FF	#	LEA	-4200(%eax), %ecx
	51			#	PUSH	%ecx
	8D 48 A0		#	LEA	-96(%eax), %ecx
.L12:
	41			#	INCL	%ecx
	#  We need to check that we're not going to overflow the buffer.  
	#  But in fact, the instruction table limit is 12 characters (incl.
	#  null termination -- i.e. 11 without), so we use that limit.
	8B 45 08		#	MOVL	8(%ebp), %eax
	8D 50 A0		#	LEA	-96(%eax), %edx
	29 CA			#	SUBL	%ecx, %edx
	83 FA F5		#	CMPL	-$11, %edx
	0F 8C error		#	JL	error

	51			#	PUSH	%ecx
	E8 readonex		#	CALL	readonex
	59			#	POP	%ecx
	51			#	PUSH	%ecx
	FF 31			#	PUSH	(%ecx)
	E8 isidchr		#	CALL	isidchr
	5A			#	POP	%edx
	59			#	POP	%ecx		# restore %ecx
	83 F8 00		#	CMPL	$0, %eax
	0F 85 .L12		#	JNE	.L12		# Loop
	5A			#	POP	%edx

	#  (%ecx) is now something other than lchr.  Return it
	89 C8			#	MOVL	%ecx, %eax
	5D			#	POP	%ebp
	C3			#	RET



####	#  Function:	int read_imm( int bits, main_frame* p );
	#  Skip whitespace and then read an immediate value ($0xXX or $NNN)
	#  Returns the value read or exits if unable to read.

.L16a:
	#  Put the byte into the main buffer and read a label
	8A 45 FC		#	MOVB	-4(%ebp), %al
	8B 4D 0C		#	MOVL	12(%ebp), %ecx
	88 41 A0		#	MOVB	%al, -96(%ecx)

	FF 75 0C		#	PUSH	12(%ebp)	# main_frame
	E8 read_id		#	CALL	read_id
	59			#	POP	%ecx

	#  Get ready to unread the last byte back at the end of the function
	8B 08			#	MOVL	(%eax), %ecx
	89 4D FC		#	MOVL	%ecx, -4(%ebp)

	#  Calculate the string length
	8B 4D 0C		#	MOVL	12(%ebp), %ecx
	8D 51 A0		#	LEA	-96(%ecx), %edx
	29 D0			#	SUBL	%edx, %eax

	FF 75 0C		#	PUSH	12(%ebp)	# main_frame
	FF 75 08		#	PUSH	8(%ebp)		# bits
	50			#	PUSH	%eax		# strlen
	E8 get_label		#	CALL	get_label
	59			#	POP	%ecx
	59			#	POP	%ecx
	59			#	POP	%ecx
	89 45 F8		#	MOVL	%eax, -8(%ebp)

	#  Unread the last character read
	59			#	POP	%ecx		# Overwrite 
	FF 75 FC		#	PUSH	-4(%ebp)	#   bufp
	E8 unread		#	CALL	unread

	#  Stack cleanup and exit
	8B 45 F8		#	MOVL	-8(%ebp), %eax	# return val
	83 C4 14		#	ADDL	$20, %esp
	5D			#	POP	%ebp
	C3			#	RET

read_imm:
	#  The function entry point
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	31 C9			#	XORL	%ecx, %ecx
	51			#	PUSH	%ecx		# char buf[4];
	51			#	PUSH	%ecx		# int val = 0;
	51			#	PUSH	%ecx		# int count = 0;

	#  Skip horizontal whitespace
	8B 4D 0C		#	MOVL	12(%ebp), %ecx
	8D 89 98 EF FF FF	#	LEA	-4200(%ecx), %ecx
	51			#	PUSH	%ecx		# ifile
	E8 skiphws		#	CALL	skiphws

	#  Check it is a '$' marking the start of an immediate;
	#  if not, it must be an identifier
	8D 4D FC		#	LEA	-4(%ebp), %ecx
	51			#	PUSH	%ecx		# char* bufp
	E8 readonex		#	CALL	readonex
	80 7D FC 24		#	CMPB	$0x24, -4(%ebp)	# '$'
	0F 85 .L16a		#	JNE	.L16a

	#  It's an integer
	5A			#	POP	%edx		# bufp
	FF 75 08		#	PUSH	8(%ebp)		# bits
	E8 read_int		#	CALL	read_int

	#  Stack clean-up and exit
	83 C4 14		#	ADDL	$20, %esp
	5D			#	POP	%ebp
	C3			#	RET


####	#  Function:	void write_oc12( int opcode_info, main_frame* )
	#  Uses the second byte in opcode_info to determine how many
	#  bytes to write (1 or 2) and then writes the third and perhaps
	#  fourth byte out.
.L19:
	5B			#	POP	%ebx	# ofile
	5B			#	POP	%ebx	# Restore %ebx
	5D			#	POP	%ebp
	C3			#	RET

write_oc12:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp
	53			#	PUSH	%ebx	# Save %ebx

	#  Find the ofile object
	8B 45 0C		#	MOVL	12(%ebp), %eax
	8D 88 90 EF FF FF	#	LEA	-4208(%eax), %ecx
	51			#	PUSH	%ecx

	#  Unconditionally write the first byte
	8B 55 08		#	MOVL	8(%ebp), %edx
	89 D3			#	MOVL	%edx, %ebx
	C6 C1 10		#	MOVB	$16, %cl
	D3 EB			#	SHRL	%cl, %ebx
	53			#	PUSH	%ebx
	E8 writebyte		#	CALL	writebyte
	5B			#	POP	%ebx

	#  Is there a second byte?
	8B 55 08		#	MOVL	8(%ebp), %edx
	80 FE 01		#	CMPB	$1, %dh
	0F 8E .L19		#	JLE	.L19
	C6 C1 08		#	MOVB	$8, %cl
	D3 EB			#	SHRL	%cl, %ebx
	53			#	PUSH	%ebx
	E8 writebyte		#	CALL	writebyte
	5B			#	POP	%ebx
	E9 .L19			#	JMP	.L19


####	#  Function:	void write_modrm( int rm, int reg, int disp, ofile* )
.L20:
	5A			#	POP	%edx		# ofile
	5D			#	POP	%ebp
	C3			#	RET

write_modrm:
	55			#	PUSH	%ebp
	89 E5			#	MOVL	%esp, %ebp

	#  Or reg (or opcode) bits <<3 with rm and put in %al
	8B 45 08		#	MOVL	8(%ebp), %eax	# rm
	8B 55 0C		#	MOVL	12(%ebp), %edx	# reg
	C6 C1 03		#	MOVB	$3, %cl
	D3 E2			#	SHLL	%cl, %edx
	08 D0			#	ORB	%dl, %al

	#  Write the ModR/M byte
	FF 75 14		#	PUSH	20(%ebp)	# ofile
	50			#	PUSH	%eax		# byte
	E8 writebyte		#	CALL	writebyte
	58			#	POP	%eax

	#  Do we have a disp32?  NB: We don't support disp8s
	3C 80			#	CMPB 	$0x80, %al
	0F 82 .L20		#	JB	.L20
	3C C0			#	CMPB	$0xC0, %al
	0F 83 .L20		#	JAE	.L20

	#  Yes.   ofile already on stack
	FF 75 10		#	PUSH	16(%ebp)		# disp
	E8 writedword		#	CALL	writedword
	5B			#	POP	%ebx
	E9 .L20			#	JMP	.L20

	
####    #  The main function.
	#  Stack is arranged as follows:
	#
	#	-4(%ebp)	instrct* mnemonics
	#       -8(%ebp)	label* label_end
	#      -12(%ebp)	label* label_end_store
	#      -96(%ebp)	char buffer[80]
	#    -4192(%ebp)	label labels[64]
	#    -4200(%ebp)        ifile fin
	#    -4208(%ebp)	ofile fout
	#
	#  where label is a { char name[12]; int addr; },
	#  instrct is a { char name[12]; char type; char data[3]; },
	#  ifile is a { int fd; bool has_pback :8; char pback_char; int:16; }.
	#  and ofile is a { int fd; int count; }.

ret:
	#  This ret is labelled to allow various bits of main to
	#  jump up to it in order to effect a forwards jump.
	31 C0			#	XORL	%eax, %eax
ret1:
	C3			#	RET

	#  --- Test for a comment.
	#  If found, skip over comment line until we've read a LF
	#  At end of section, %eax=1 iff we read a comment.
	#  If %eax=0, all other registers are unaltered.
comment:
	80 7D A0 23             #       CMPB    $0x23, -96(%ebp)        # '#'
	0F 85 ret		#	JNE	ret
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	8D 4D A0		#	LEA	-96(%ebp), %ecx
	51			#	PUSH	%ecx
.L10:
	E8 readonex		#	CALL	readonex
	80 7D A0 0A		#	CMPB	$0x0A, -96(%ebp)	# '\n'
	0F 85 .L10		#	JNE	.L10
	5A			#	POP	%edx
	5A			#	POP	%edx
	B8 01 00 00 00		#	MOVL	$1, %eax
	C3			#	RET	# to main loop

	#  Parts of the label section
labeldef:
	#  Check that we're not about to over run the label store,
	#  and then store the label
	8D 5D F8		#	LEA	-8(%ebp), %ebx
	8B 3B			#	MOVL	(%ebx), %edi
	8B 45 F4		#	MOVL	-12(%ebp), %eax
	39 C7			#	CMPL	%eax, %edi
	0F 8D error		#	JGE	error
	F3			#	REP
	   A4			#	  MOVSB
	8B 85 94 EF FF FF	#	MOVL	-4204(%ebp), %eax #ofile->count
	8B 3B			#	MOVL	(%ebx), %edi
	89 47 0C		#	MOVL	%eax, 12(%edi)
	83 03 10		#	ADDL	$16, (%ebx)
	B8 01 00 00 00		#	MOVL	$1, %eax
	C3			#	RET	# to main loop

insn_end:
	B8 01 00 00 00		#	MOVL	$2, %eax
	E9 ret1			#	JMP	ret1

type_00:
	#  Write out a type 00 instruction.  These are easiest as they
	#  have no parameters.
	55			#	PUSH	%ebp		# main_frame
	52			#	PUSH	%edx	# opcode info
	E8 write_oc12		#	CALL	write_oc12
	5A			#	POP	%edx
	5A			#	POP	%edx
	E9 insn_end		#	JMP	insn_end

type_01:
	#  Write the opcode byte(s).
	55			#	PUSH	%ebp		# main_frame
	52			#	PUSH	%edx	# opcode info
	E8 write_oc12		#	CALL	write_oc12
	5A			#	POP	%edx

	#  Skip ws and read immediate.
	53			#	PUSH	%ebx
	E8 read_imm		#	CALL	read_imm
	59			#	POP	%ecx
	59			#	POP	%ecx

	#  Byte is in %al (as part of return from read_imm): write it.
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx	# ofile
	51			#	PUSH	%ecx
	50			#	PUSH	%eax
	53			#	PUSH	%ebx
	E8 writedata		#	CALL	writedata
	5A			#	POP	%edx
	5A			#	POP	%edx
	5A			#	POP	%edx
	E9 insn_end		#	JMP	insn_end

type_03:
	#  Write the opcode byte(s).
	55			#	PUSH	%ebp		# main_frame
	52			#	PUSH	%edx	# opcode info
	E8 write_oc12		#	CALL	write_oc12
	5A			#	POP	%edx
	59			#	POP	%ecx

	#  Read the r/m
	52			#	PUSH	%edx	# store opcode info
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	8D 4D A0		#	LEA	-96(%ebp), %ecx		# disp
	51			#	PUSH	%ecx
	53			#	PUSH	%ebx		# bits
	E8 read_rm		#	CALL	read_rm
	83 C4 0C		#	ADDL	$12, %esp
	5A			#	POP	%edx

.L21:
	#  Write the ModR/M byte and (if present) displacement.
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx	# ofile
	51			#	PUSH	%ecx
	FF 75 A0		#	PUSH	-96(%ebp)	# disp
	C6 C1 18		#	MOVB	$24, %cl
	D3 EA			#	SHRL	%cl, %edx
	52			#	PUSH	%edx		# reg bits
	50			#	PUSH	%eax		# modrm
	E8 write_modrm		#	CALL	write_modrm
	83 C4 10		#	ADDL	$16, %esp
	E9 insn_end		#	JMP	insn_end

type_05:
	#  Write the opcode byte(s).
	55			#	PUSH	%ebp		# main_frame
	52			#	PUSH	%edx	# opcode info
	E8 write_oc12		#	CALL	write_oc12
	5A			#	POP	%edx
	59			#	POP	%ecx

.L22:
	#  Read the r/m
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	8D 4D A0		#	LEA	-96(%ebp), %ecx		# disp
	51			#	PUSH	%ecx
	53			#	PUSH	%ebx			# bits
	E8 read_rm		#	CALL	read_rm
	5B			#	POP	%ebx			# bits
	59			#	POP	%ecx
	59			#	POP	%ecx

	# Skip ws, read a comma, then skip more ws and read the '%' and reg
	50			#	PUSH	%eax	# store r/m
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	E8 getone		#	CALL	getone
	3C 2C			#	CMPB	$0x2C, %al	# ','
	0F 85 error		#	JNE	error
	E8 skiphws		#	CALL	skiphws
	E8 getone		#	CALL	getone
	3C 25			#	CMPB	$0x25, %al	# '%'
	0F 85 error		#	JNE	error
	53			#	PUSH	%ebx		# bits
	E8 read_reg		#	CALL	read_reg
	5A			#	POP	%edx	# bits
	5A			#	POP	%edx	# ifile
	5A			#	POP	%edx	# r/m

.L22a:
	#  Write the ModR/M byte and (if present) displacement.
	#  So: $edx is r/m, $eax is reg
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx	# ofile
	51			#	PUSH	%ecx
	FF 75 A0		#	PUSH	-96(%ebp)	# disp
	50			#	PUSH	%eax		# reg
	52			#	PUSH	%edx		# rm
	E8 write_modrm		#	CALL	write_modrm
	83 C4 10		#	ADDL	$16, %esp
	E9 insn_end		#	JMP	insn_end

type_06_rm:
	#  %edx contains the opcode info, so %dh+2 is the opcode.  Write it.
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx
	51			#	PUSH	%ecx
	88 F0			#	MOVB	%dh, %al
	83 C0 02		#	ADDL	$2, %eax
	50			#	PUSH	%eax
	E8 writebyte		#	CALL	writebyte
	59			#	POP	%ecx
	59			#	POP	%ecx

	E9 .L22			#	JMP	.L22

type_06_reg:
	#  %edx contains the opcode info, so %dh is the opcode.  Write it.
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx
	51			#	PUSH	%ecx
	88 F0			#	MOVB	%dh, %al
	50			#	PUSH	%eax
	E8 writebyte		#	CALL	writebyte
	59			#	POP	%ecx
	59			#	POP	%ecx

.L23:
	#  Read the register
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	E8 getone		#	CALL	getone
	3C 25			#	CMPB	$0x25, %al	# '%'
	0F 85 error		#	JNE	error
	53			#	PUSH	%ebx		# bits
	E8 read_reg		#	CALL	read_reg
	5B			#	POP	%ebx			# bits
	59			#	POP	%ecx

.L23a:
	#  Skip ws, read a comma, then skip more ws and read the '%' and r/m
	#  We expect %eax to contain the reg bytes already read, and
	#  %ebx the number of bits.
	50			#	PUSH	%eax	# store reg
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	E8 getone		#	CALL	getone
	3C 2C			#	CMPB	$0x2C, %al	# ','
	0F 85 error		#	JNE	error
	8D 4D A0		#	LEA	-96(%ebp), %ecx		# disp
	51			#	PUSH	%ecx
	53			#	PUSH	%ebx			# bits
	E8 read_rm		#	CALL	read_rm
	89 C2			#	MOVL	%eax, %edx
	5B			#	POP	%ebx		# bits
	59			#	POP	%ecx		# disp
	59			#	POP	%ecx		# ifile
	58			#	POP	%eax	# retrieve reg

	#  Write the ModR/M byte.
	E9 .L22a		#	JMP	.L22a

.L23b:
	#  This is the easy case: the immediate is a literal
	52			#	PUSH	%edx		# store op info
	55			#	PUSH	%ebp
	53			#	PUSH	%ebx		
	E8 read_imm		#	CALL	read_imm
	59			#	POP	%ecx
	59			#	POP	%ecx
	5A			#	POP	%edx		# opinfo

	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx
	51			#	PUSH	%ecx		# ofile
	50			#	PUSH	%eax		# data
	53			#	PUSH	%ebx		# bits

	#  Messy.  Call into the {.L23a, .L22a, insn_end, ret1} block.
	#  That isn't a real function.   It expects %al to contain reg bits
	88 F0			#	MOVB	%dh, %al
	E8 .L23a		#	CALL	.L23a

	#  Now write the immediate.  The stack is already set up.
	E8 writedata		#	CALL	writedata
	5B			#	POP	%ebx
	59			#	POP	%ecx
	59			#	POP	%ecx
	E9 insn_end		#	JMP	insn_end
	

type_06_imm:
	#  Shift %edx so %dl is the opcode byte and %dh the extension bits
	C6 C1 10		#	MOVB	$16, %cl
	D3 EA			#	SHRL	%cl, %edx
	52			#	PUSH	%edx		# store op info

	#  Write the opcode byte from %dl
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx
	51			#	PUSH	%ecx
	88 D0			#	MOVB	%dl, %al
	50			#	PUSH	%eax
	E8 writebyte		#	CALL	writebyte
	59			#	POP	%ecx
	59			#	POP	%ecx

	#  The AT&T naming convention makes this awkward.  We need to 
	#  write the ModR/M bytes *before* looking up the symbol in the 
	#  immediate.  Unfortunately, in AT&T syntax, the immediate is before 
	#  the r/m argument which means we don't know whether it's a got 
	#  a disp word.

	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	59			#	POP	%ecx
	5A			#	POP	%edx	# retrieve op info
	3C 24			#	CMPB	$0x24, %al	# '$'
	0F 84 .L23b		#	JE	.L23b
	
	#  We've got a an intermediate label.  Get first char into buffer,
	#  and then read the label.
	52			#	PUSH	%edx		# store op info
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 getone		#	CALL	getone
	88 45 A0		#	MOVB	%al, -96(%ebp)
	55			#	PUSH	%ebp		# main_frame
	E8 read_id		#	CALL	read_id
	59			#	POP	%ecx
	59			#	POP	%ecx		# ifile
	
	#  Write back the last byte
	50			#	PUSH	%eax		# save endp
	51			#	PUSH	%ecx		# ifile
	FF 30			#	PUSH	(%eax)		# char
	E8 unread		#	CALL	unread
	5A			#	POP	%ecx
	5A			#	POP	%ecx		# ifile
	58			#	POP	%eax		# endp

	#  Calculate the string length
	8D 55 A0		#	LEA	-96(%ebp), %edx
	29 D0			#	SUBL	%edx, %eax
	59			#	POP	%ecx	# retrieve op info
	55			#	PUSH	%ebp		# main_frame
	53			#	PUSH	%ebx		# bits
	50			#	PUSH	%eax		# strlen
	FF 32			#	PUSH	(%edx)		# first dword

	#  Now call into the {.L23a, .L22a, insn_end, ret1} block to handle
	#  the ModR/M (incl. disp32).   Urgh.
	88 E8			#	MOVB	%ch, %al
	E8 .L23a		#	CALL	.L23a

	#  Restore first dword of the label, and then look up the immediate
	#  label now that ModR/M is written
	8F 45 A0		#	POP	-96(%ebp)
	E8 get_label		#	CALL	get_label
	59			#	POP	%ecx
	5B			#	POP	%ebx		# bits
	59			#	POP	%ecx

	#  And write the immediate data
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx
	51			#	PUSH	%ecx
	50			#	PUSH	%eax		# byte(s)
	53			#	PUSH	%ebx		# bits
	E8 writedata		#	CALL	writedata
	59			#	POP	%ecx
	59			#	POP	%ecx
	59			#	POP	%ecx

	E9 insn_end		#	JMP	insn_end

type_06:
	#  First, skip whitespace, leaving %eax containing the peek-ahead char
	52			#	PUSH	%edx	# opcode info
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	59			#	POP	%ecx	# ifile
	5A			#	POP	%edx

	#  Need to determine which of the three types of instruction it is.
	3C 25			#	CMPB	$0x25, %al	# '%'
	0F 84 type_06_reg	#	JE	type_06_reg
	3C 28			#	CMPB	$0x28, %al	# '('
	0F 84 type_06_rm	#	JE	type_06_rm
	3C 2D			#	CMPB	$0x2D, %al	# '-'
	0F 84 type_06_rm	#	JE	type_06_rm
	50			#	PUSH	%eax
	E8 dchr			#	CALL	dchr
	59			#	POP	%ecx
	3C FF			#	CMPB	$-1, %al
	0F 85 type_06_rm	#	JNE	type_06_rm
	E9 type_06_imm		#	JMP	type_06_imm

hex_bytes:
	#  Skip horizontal whitespace and read a byte
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	59			#	POP	%ecx

	#  Is it a line ending?  If so, end parsing the directive.
	3C 0A			#	CMPB	$0x0A, %al	# '\n'
	0F 84 insn_end		#	JE	insn_end
	3C 3B			#	CMPB	$0x3B, %al	# ';'
	0F 84 insn_end		#	JE	insn_end
	3C 23			#	CMPB	$0x23, %al	# '#'
	0F 84 insn_end		#	JE	insn_end

	51			#	PUSH	%ecx		# ifile
	8D 4D A0		#	LEA	-96(%ebp), %ecx
	51			#	PUSH	%ecx
	E8 readonex		#	CALL	readonex
	5A			#	POP	%edx
	5A			#	POP	%edx

	#  Start parsing an octet
	FF 75 A0		#	PUSH	-96(%ebp)
	E8 xchr			#	CALL	xchr
	5B			#	POP	%ebx
	3C FF			#	CMPB	$-1, %al
	0F 84 error		#	JE	error

	#  Read the next byte
	50			#	PUSH	%eax
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	8D 4D A1		#	LEA	-95(%ebp), %ecx
	51			#	PUSH	%ecx
	E8 readonex		#	CALL	readonex
	5A			#	POP	%edx
	5A			#	POP	%edx
	5B			#	POP	%ebx	# The first byte

	#  Process it
	FF 75 A1		#	PUSH	-95(%ebp)
	E8 xchr			#	CALL	xchr
	5A			#	POP	%edx
	83 F8 FF		#	CMPL	$-1, %eax
	0F 84 error		#	JE	error
	C6 C1 04		#	MOVB	$4, %cl
	D2 E3			#	SALB	%cl, %bl
	00 D8			#	ADDB	%bl, %al

	#  Byte is in %al; let's write it, and increment the address counter
	8D 8D 90 EF FF FF	#	LEA	-4208(%ebp), %ecx	# ofile
	51			#	PUSH	%ecx
	50			#	PUSH	%eax
	E8 writebyte		#	CALL	writebyte
	5B			#	POP	%ebx
	5B			#	POP	%ebx
	0F 85 hex_bytes		#	JNE	hex_bytes


	#  --- Test for an identifier at top level in the source file.
	#  This might be a label, a mnemonic or a directive.
tl_ident:
	55			#	PUSH	%ebp
	E8 read_id		#	CALL	read_id
	59			#	POP	%ecx
	89 C1			#	MOVL	%eax, %ecx

	#  (%ecx) is now something other than lchr.  Is it a colon?
	#  Also, null terminate, load %esi with start of string, and
	#  %ecx with its length inc. NUL.
	80 39 3A		#	CMPB	$0x3A, (%ecx)        # ':'
	9C			#	PUSHF
	8B 11			#	MOVL	(%ecx), %edx
	C6 01 00		#	MOVB	$0, (%ecx)	# '\0' term.
	41			#	INCL	%ecx
	8D 75 A0		#	LEA	-96(%ebp), %esi
	29 F1			#	SUBL	%esi, %ecx
	83 F9 12		#	CMPL	$12, %ecx
	0F 8F error		#	JG	error
	9D			#	POPF
	0F 84 labeldef		#	JE	labeldef

	#  It must be either a directive or an instruction
	8D 85 98 EF FF FF	#	LEA	-4200(%ebp), %eax	# ifile
	51			#	PUSH	%ecx	# we care about this
	50			#	PUSH	%eax
	52			#	PUSH	%edx
	E8 unread		#	CALL	unread
	59			#	POP	%ecx
	59			#	POP	%ecx
	59			#	POP	%ecx

	#  Look up the mnemonic or directive
	#  %esi points to the null-terminated identifier name
	8B 7D FC		#	MOV	-4(%ebp), %edi
	81 EF 10 00 00 00	#	SUBL	$16, %edi
.L14a:
	83 C7 10		#	ADDL	$16, %edi
	81 3F 00 00 00 00  	#	CMPL	$0, (%edi)
	0F 84 error		#	JE	error
	51			#	PUSH	%ecx
	56			#	PUSH	%esi
	57			#	PUSH	%edi
	F3			#	REPE
	   A6			#	  CMPSB
	5F			#	POP	%edi
	5E			#	POP	%esi
	59			#	POP	%ecx
	0F 85 .L14a		#	JNE	.L14a

	#  Found the mnemonic or directive.  Get it's type (and parameters)
	#  and see whether it's a directive (which must be a .hex_bytes)
	8B 57 0C 		#	MOVL	$12(%edi), %edx
	80 FA FF 		#	CMPB	$FF, %dl
	0F 84 hex_bytes 	#	JE	hex_bytes

	#  Instructions with 8-bit operands
	BB 08 00 00 00		#	MOVL	$8, %ebx	# 8-bit mode
	80 FA 00		#	CMPB	$0, %dl
	0F 84 type_00		#	JE	type_00
	80 FA 01		#	CMPB	$1, %dl
	0F 84 type_01		#	JE	type_01
	80 FA 03		#	CMPB	$3, %dl
	0F 84 type_03		#	JE	type_03
	80 FA 06		#	CMPB	$6, %dl
	0F 84 type_06		#	JE	type_06

	#  Instructions with 32-bit operands
	BB 20 00 00 00		#	MOVL	$32, %ebx	# 32-bit mode
	80 FA 02		#	CMPB	$2, %dl
	0F 84 type_01		#	JE	type_01		# 1 & 2 same
	80 FA 04		#	CMPB	$4, %dl
	0F 84 type_03		#	JE	type_03		# 3 & 4 same
	80 FA 05		#	CMPB	$5, %dl
	0F 84 type_05		#	JE	type_05
	80 FA 07		#	CMPB	$7, %dl
	0F 84 type_06		#	JE	type_06		# 6 & 7 same

	E9 error		#	JMP	error
	C3			#	RET	# to main loop

.L8:
	#  Read one byte (not with readonex because EOF is permitted)
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx
	51			#	PUSH	%ecx
	8D 4D A0		#	LEA	-96(%ebp), %ecx
	51			#	PUSH	%ecx
	E8 readone		#	CALL	readone
	5A			#	POP	%edx
	5A			#	POP	%edx
	83 F8 00		#	CMPL	$0, %eax
	0F 8C error		#	JL	error
	89 C3			#	MOVL	%eax, %ebx  # zero exit status
	0F 84 ret1		#	JE	ret1

	#  Is the byte white space?  If so, loop back
	8A 45 A0		#	MOVB	-96(%ebp), %al
	50			#	PUSH	%eax
	E8 isws			#	CALL	isws
	83 F8 00		#	CMPL	$0, %eax
	5A			#	POP	%edx
	0F 85 .L8		#	JNE	.L8

	#  We have a byte.  What is it?
	E8 comment		#	CALL	comment
	83 F8 00		#	CMP	$0, %eax
	0F 85 .L8		#	JNE	.L8

	#  Or perhaps a top-level identifier (label / mnemonic / directive);
	#  nothing else is permitted here.
	E8 tl_ident		#	CALL	tl_ident
	83 F8 00		#	CMP	$0, %eax
	0F 84 error		#	JE	error
	83 F8 00		#	CMP	$1, %eax
	0F 84 .L8		#	JE	.L8

	#  We only get here if we've had an instruction or directive (as 
	#  opposed to a comment, label, or whitespace.)
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 skiphws		#	CALL	skiphws
	59			#	POP	%ecx	# ifile

	#  Ordinarily, the next character should be either a '\n', '#' or ';',
	#  but we'll be permissive here to allow things like REPE CMPSB.  So
	#  we make the ';' between instructions on a single line optional.
	3C 3B			#	CMPB	$0x3B, %al	# ';'
	0F 85 .L8		#	JNE	.L8	# Permissive

	#  Skip over the semicolon (statement separator)
	8D 8D 98 EF FF FF	#	LEA	-4200(%ebp), %ecx	# ifile
	51			#	PUSH	%ecx
	E8 getone		#	CALL	getone
	59			#	POP	%ecx	# ifile

	#  Nothing else is permitted here.	
	E9 .L8		#	JMP	.L8
	#  --- The main loop
main:
	89 E5			#	MOVL	%esp, %ebp
	81 EC 74 10 00 00	#	SUBL	$4212, %esp
	#  label* label_end = &labels[0];
	8D 85 A0 EF FF FF	#	LEA	-4192(%ebp), %eax
	89 45 F8		#	MOVL	%eax, -8(%ebp)
	#  label* label_end_store = &labels[256];  # 4096 == 256*sizeof(label)
	81 C0 00 10 00 00	#	ADDL	$4096, %eax
	89 45 F4		#	MOVL	%eax, -12(%ebp)

	#  Check we have a command line argument
	81 7D 00 02 00 00 00	#	CMPL	$2, 0(%ebp)
	0F 85 error		#	JNE	error

	#  Open the file
	31 C9			#	XORL	%ecx, %ecx
	8B 5D 08		#	MOVL	8(%ebp), %ebx
	B8 05 00 00 00		#	MOVL	$5, %eax	# 3 = __NR_open
	CD 80			#	INT	$0x80
	83 F8 00		#	CMPL	$0, %eax
	0F 8C error		#	JL	error

	#  memset( &fout, 0, sizeof(ofile) );
	#  No write on first pass, so fout.fd = -1
	C7 85 90 EF FF FF FF FF FF FF #	MOVL	$-1, -4208(%ebp)
	C7 85 94 EF FF FF 00 00 00 00 #	MOVL	$0, -4204(%ebp)

	#  memset( &fin, 0, sizeof(ifile) );
	89 85 98 EF FF FF	#	MOVL	%eax, -4200(%ebp)
	C7 85 9C EF FF FF 00 00 00 00 #	MOVL	$0, -4196(%ebp)

	#  Locate the mnemonics table:  instrct* mnemonics = &mnemonics;
	E8 getip		#	CALL	getip
	81 C0 mnemonics		#	ADDL	mnemonics, %eax
	81 C0 06 00 00 00	#	ADDL	$6, %eax   # len of prev instr
	89 45 FC		#	MOVL	%eax, -4(%ebp)

	E8 .L8			#	CALL	.L8

	#  Set fout.fd = 1 (for stdout) to initiate writing, and reset counter
	C7 85 90 EF FF FF 01 00 00 00 #	MOVL	$1, -4208(%ebp)
	C7 85 94 EF FF FF 00 00 00 00 #	MOVL	$0, -4204(%ebp)

	#  Seek to the beginning of the file for second pass
	31 D2			#	XORL	%edx, %edx	SEEK_SET=0
	31 C9			#	XORL	%ecx, %ecx	offset = 0
	8B 9D 98 EF FF FF	#	MOVL	-4200(%ebp), %ebx	# fd
	C7 C0 13 00 00 00	#	MOVL	$19, %eax	# _NR_lseek
	CD 80			#	INT	$0x80
	81 F8 00 00 00 00	#	CMPL	$0, %eax
	0F 8C success		#	JL	error

	E8 .L8			#	CALL	.L8
	E9 success		#	JMP	success

####    #  And finally, the entry point.
	#  Last per requirement for elfify.
	E9 main                 #       JMP     main

